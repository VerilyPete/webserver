#cloud-config
package_update: true
package_upgrade: false
package_reboot_if_required: false

packages:
  - git
  - curl
  - wget
  - nano
  - htop
  - jq
  - iptables
  - iproute-tc
  - policycoreutils-python-utils

write_files:
  - path: /usr/local/bin/setup-k0s-worker.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      echo "=== Starting K0s Worker Setup ==="

      # Download and install k0s
      echo "Downloading k0s..."
      curl -sSLf https://get.k0s.sh | sudo sh

      # Create kubectl alias for convenience
      echo "alias kubectl='k0s kubectl'" >> /home/opc/.bashrc
      echo "alias k='k0s kubectl'" >> /home/opc/.bashrc

      echo "=== K0s Worker Setup Complete ==="
      echo "NOTE: This node needs to be joined to the cluster"
      echo "The join will be completed by the deployment script"

  - path: /usr/local/bin/install-tailscale.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      echo "=== Installing Tailscale ==="

      # Check and handle SELinux for Tailscale
      echo "Checking SELinux status..."
      if command -v getenforce >/dev/null 2>&1; then
        SELINUX_STATUS=$(getenforce)
        echo "SELinux status: $SELINUX_STATUS"
        
        if [ "$SELINUX_STATUS" = "Enforcing" ]; then
          echo "SELinux is enforcing, configuring for Tailscale..."
          
          # Allow SSH connections through non-standard interfaces
          setsebool -P ssh_sysadm_login 1 2>/dev/null || echo "Could not set ssh_sysadm_login"
          setsebool -P nis_enabled 1 2>/dev/null || echo "Could not set nis_enabled"
          
          # Allow network connections
          setsebool -P domain_kernel_load_modules 1 2>/dev/null || echo "Could not set domain_kernel_load_modules"
          
          # Set SELinux to permissive mode temporarily for setup
          echo "Setting SELinux to permissive mode for Tailscale setup..."
          setenforce 0 || echo "Could not set SELinux to permissive"
          
          echo "SELinux configuration for Tailscale completed"
        fi
      else
        echo "SELinux not available"
      fi

      # Install Tailscale
      curl -fsSL https://tailscale.com/install.sh | sh

      # Start Tailscale with provided auth key
      if [ -n "${TAILSCALE_AUTH_KEY}" ]; then
        echo "Starting Tailscale..."
        if [ -n "${HOSTNAME}" ]; then
          tailscale up --authkey="${TAILSCALE_AUTH_KEY}" --hostname="${HOSTNAME}" --accept-dns=false
        else
          echo "ERROR: HOSTNAME not provided"
          exit 1
        fi
        echo "Tailscale started successfully"
        
        # Fix DNS configuration to prevent conflicts
        echo "Configuring DNS to prevent conflicts..."
        # Backup original resolv.conf if it doesn't exist
        if [ ! -f /etc/resolv.conf.backup ]; then
          cp /etc/resolv.conf /etc/resolv.conf.backup 2>/dev/null || true
        fi
        
        # Ensure we have proper DNS servers
        if ! grep -q "100.100.100.100" /etc/resolv.conf; then
          echo "nameserver 100.100.100.100" >> /etc/resolv.conf
        fi
        if ! grep -q "8.8.8.8" /etc/resolv.conf; then
          echo "nameserver 8.8.8.8" >> /etc/resolv.conf
        fi
        
      else
        echo "ERROR: TAILSCALE_AUTH_KEY not provided"
        exit 1
      fi

      echo "=== Tailscale Installation Complete ==="

  - path: /usr/local/bin/mount-block-volume.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -euo pipefail

      echo "=== Checking for Block Volume ==="

      # Wait for device to be available
      sleep 10

      # Find the attached volume (usually /dev/sdb or /dev/oracleoci/oraclevdb)
      DEVICE=""
      for dev in /dev/sdb /dev/oracleoci/oraclevdb; do
        if [ -b "$dev" ]; then
          DEVICE="$dev"
          break
        fi
      done

      if [ -z "$DEVICE" ]; then
        # Try to find any additional block device
        DEVICE=$(lsblk -dpno NAME,SIZE | grep -v "sda" | awk 'NR==1 {print $1}')
      fi

      if [ -n "$DEVICE" ] && [ -b "$DEVICE" ]; then
        echo "Found block device: $DEVICE"

        # Create filesystem if needed
        if ! blkid "$DEVICE" 2>/dev/null; then
          echo "Creating ext4 filesystem on $DEVICE"
          mkfs.ext4 -F "$DEVICE"
        fi

        # Mount the volume
        mkdir -p /mnt/data
        mount "$DEVICE" /mnt/data

        # Add to fstab for persistence
        DEVICE_UUID=$(blkid -s UUID -o value "$DEVICE")
        if [ -n "$DEVICE_UUID" ]; then
          echo "UUID=$DEVICE_UUID /mnt/data ext4 defaults,nofail 0 2" >> /etc/fstab
        else
          echo "$DEVICE /mnt/data ext4 defaults,nofail 0 2" >> /etc/fstab
        fi

        # Create directories for Kubernetes persistent volumes
        mkdir -p /mnt/data/k8s-pv-prometheus
        mkdir -p /mnt/data/k8s-pv-grafana
        mkdir -p /mnt/data/k8s-pv-generic
        chmod 777 /mnt/data/k8s-pv-*

        echo "Block volume mounted successfully at /mnt/data"
        ls -la /mnt/data/
      else
        echo "No additional block device found - skipping mount"
      fi

runcmd:
  # Set hostname first using custom metadata
  - |
    HOSTNAME=$(curl -s -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata | jq -r '.HOSTNAME')
    if [ "$HOSTNAME" != "null" ] && [ -n "$HOSTNAME" ]; then
      hostnamectl set-hostname $HOSTNAME
      echo "Set hostname to: $HOSTNAME"
      # Also update /etc/hostname for persistence
      echo "$HOSTNAME" > /etc/hostname
    else
      echo "ERROR: Could not retrieve HOSTNAME from custom metadata"
      exit 1
    fi

  # Configure firewall for K0s cluster communication
  - |
    echo "Configuring firewall for cluster communication..."
    if systemctl is-enabled firewalld >/dev/null 2>&1; then
      echo "Firewalld is enabled, configuring rules..."
      
      # Allow traffic from private subnet (adjust subnet as needed)
      sudo firewall-cmd --permanent --add-source=10.0.1.0/24
      
      # Allow pod network traffic (Kubernetes pods)
      sudo firewall-cmd --permanent --add-source=10.244.0.0/16
      
      # Allow service network traffic (Kubernetes services)
      sudo firewall-cmd --permanent --add-source=10.96.0.0/12
      
      # Create systemd service to apply iptables bypass rule after k0s starts
      cat > /etc/systemd/system/k0s-iptables-fix.service << 'EOSVC'
[Unit]
Description=Apply iptables bypass rule for k0s pod network
After=network-online.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/bin/bash -c 'for i in {1..30}; do if systemctl is-active k0sworker >/dev/null 2>&1; then sleep 30; iptables -I FORWARD 1 -s 10.244.0.0/16 -d 10.244.0.0/16 -j ACCEPT; iptables-save > /etc/iptables/rules.v4; exit 0; fi; sleep 10; done; exit 1'
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOSVC
      
      # Enable the service to run on boot
      sudo systemctl enable k0s-iptables-fix.service
      
      # Create iptables directory for rule persistence
      sudo mkdir -p /etc/iptables
      
      # Allow specific K0s ports
      sudo firewall-cmd --permanent --add-port=10250/tcp # Kubelet API
      sudo firewall-cmd --permanent --add-port=8132/tcp  # Konnectivity agent
      sudo firewall-cmd --permanent --add-port=179/tcp   # Kube-router BGP
      sudo firewall-cmd --permanent --add-port=30000-32767/tcp # NodePort services
      
      # Allow SSH for management
      sudo firewall-cmd --permanent --add-service=ssh
      
      # Reload firewall rules
      sudo firewall-cmd --reload
      
      echo "Firewall configured for K0s worker"
      sudo firewall-cmd --list-all
    else
      echo "Firewalld not enabled, skipping firewall configuration"
    fi

  # Setup Tailscale for connectivity
  - |
    # Get metadata from OCI metadata service (custom metadata)
    METADATA=$(curl -s -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata)
    export TAILSCALE_AUTH_KEY=$(echo "$METADATA" | jq -r '.TAILSCALE_AUTH_KEY')
    export HOSTNAME=$(echo "$METADATA" | jq -r '.HOSTNAME')
    
    echo "Setting up Tailscale with hostname: $HOSTNAME"
    echo "Auth key length: ${#TAILSCALE_AUTH_KEY}"
    
    if [ -z "$TAILSCALE_AUTH_KEY" ] || [ "$TAILSCALE_AUTH_KEY" = "null" ]; then
      echo "ERROR: Failed to retrieve TAILSCALE_AUTH_KEY from metadata"
      exit 1
    fi
    
    if [ -z "$HOSTNAME" ] || [ "$HOSTNAME" = "null" ]; then
      echo "ERROR: Failed to retrieve HOSTNAME from metadata"
      exit 1
    fi
    
    /usr/local/bin/install-tailscale.sh

  # Give Tailscale time to establish connection and verify
  - |
    echo "Waiting for Tailscale to be ready..."
    for i in {1..30}; do  # 30 second timeout
      if tailscale status >/dev/null 2>&1; then
        echo "Tailscale is connected!"
        tailscale status
        break
      fi
      echo "Waiting for Tailscale... (attempt $i/30)"
      sleep 1
    done

  # Setup k0s worker
  - /usr/local/bin/setup-k0s-worker.sh

  # For worker-1, mount the block volume if this is that node
  - |
    HOSTNAME=$(curl -s -H "Authorization: Bearer Oracle" http://169.254.169.254/opc/v2/instance/metadata | jq -r '.HOSTNAME')
    if [ "$HOSTNAME" = "k8s-worker-1" ]; then
      echo "Setting up block storage for worker-1..."
      /usr/local/bin/mount-block-volume.sh
    fi

final_message: "K0s worker node ready! Waiting for cluster join..."
