# ============================================================================
# STAGE 4: APPLICATION DEPLOYMENT
# ============================================================================
# Purpose: Deploy Cloudflare tunnel controller and web applications
# When to use: Fresh deploys, cluster updates, and full app deployments
# Dependencies: Stage 3 (cluster)
# Outputs: Deployment status
#
# This stage:
# 1. Installs Helm on the controller node
# 2. Deploys Cloudflare Tunnel Ingress Controller via Helm chart
# 3. Deploys web application manifests (namespace, deployment, service, ingress)
# 4. Verifies all deployments are running correctly
# 5. Tests internal connectivity between services
# 6. Provides deployment summary and next steps
# ============================================================================

name: 'Deploy K0s Stage 4: Applications'

on:
  workflow_call:
    outputs:
      deployment_status:
        description: "Application deployment status"
        value: ${{ jobs.deploy-applications.outputs.deployment_status }}

  workflow_dispatch:

env:
  OCI_CLI_USER: ${{ secrets.OCI_CLI_USER }}
  OCI_CLI_TENANCY: ${{ secrets.OCI_CLI_TENANCY }}
  OCI_CLI_FINGERPRINT: ${{ secrets.OCI_CLI_FINGERPRINT }}
  OCI_CLI_KEY_CONTENT: ${{ secrets.OCI_CLI_KEY_CONTENT }}
  OCI_CLI_REGION: ${{ secrets.OCI_CLI_REGION }}

jobs:
  deploy-applications:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      deployment_status: ${{ steps.deployment_status.outputs.status }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup connectivity
        uses: ./.github/actions/setup-connectivity
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          tailscale_auth_key: ${{ secrets.PRIVATE_TAILSCALE_KEY }}

      - name: Deploy Kubernetes manifests
        run: |
          echo "üöÄ Deploying Kubernetes manifests..."

          # Copy manifests to controller
          scp -r -o StrictHostKeyChecking=no ./k0s/manifests opc@k8s-controller:/tmp/

          # Deploy on controller using Helm for Cloudflare controller
          ssh -o StrictHostKeyChecking=no opc@k8s-controller << 'EOF'
            cd /tmp/manifests

            # Install Helm if not already installed
            if ! command -v helm &> /dev/null; then
              echo "Installing Helm..."
              curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
              chmod 700 get_helm.sh
              ./get_helm.sh
              rm get_helm.sh
            fi

            # Apply basic namespaces first
            echo "Creating namespaces..."
            sudo /usr/local/bin/k0s kubectl apply -f 01-namespace.yaml

            # Deploy Cloudflare Tunnel Ingress Controller using Helm
            echo "Adding Helm repository for Cloudflare controller..."
            helm repo add strrl https://helm.strrl.dev/ || true
            helm repo update

            echo "Deploying Cloudflare tunnel controller via Helm..."
            helm upgrade --install --wait \
              -n cloudflare-tunnel --create-namespace \
              cloudflare-tunnel-ingress-controller \
              strrl/cloudflare-tunnel-ingress-controller \
              --set=cloudflare.apiToken="${{ secrets.CLOUDFLARE_K0S_TOKEN }}" \
              --set=cloudflare.accountId="${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" \
              --set=cloudflare.tunnelName="webserver-staging" \
              --set=nodeSelector."kubernetes\.io/hostname"="k8s-worker-1" \
              --set=connector.initDelaySeconds=180 \
              --timeout=300s

            echo "Verifying Cloudflare controller deployment..."
            sudo /usr/local/bin/k0s kubectl get pods -n cloudflare-tunnel -o wide
            sudo /usr/local/bin/k0s kubectl get ingressclass
            
            # Check controller logs
            echo "Controller logs:"
            sudo /usr/local/bin/k0s kubectl logs -n cloudflare-tunnel -l app.kubernetes.io/name=cloudflare-tunnel-ingress-controller --tail=50 || echo "No logs available yet"

            echo "Deploying web application..."
            sudo /usr/local/bin/k0s kubectl apply -f 04-webserver/

            echo "Waiting for web deployment..."
            sudo /usr/local/bin/k0s kubectl wait --for=condition=available --timeout=300s \
              deployment/webserver -n webserver

            echo "Waiting for service endpoints to stabilize..."
            sleep 30
            
            # Test service connectivity before Cloudflare tries to use it
            echo "Testing service readiness from within cluster..."
            for i in {1..5}; do
              if sudo /usr/local/bin/k0s kubectl run connectivity-test-$i --image=curlimages/curl --restart=Never --rm --timeout=30s -- curl -s --max-time 5 http://webserver-service.webserver.svc.cluster.local >/dev/null 2>&1; then
                echo "‚úÖ Service connectivity confirmed (attempt $i)"
                break
              else
                echo "‚è≥ Service not ready yet (attempt $i/5), waiting 30s..."
                sleep 30
              fi
            done

            echo "‚úÖ All manifests deployed and service ready"
          EOF

      - name: Verify deployment
        run: |
          echo "üîç Deployment Verification"
          ssh -o StrictHostKeyChecking=no opc@k8s-controller << 'EOF'
            echo "üìä Cluster Status:"
            echo "=================="
            sudo /usr/local/bin/k0s kubectl get nodes -o wide

            echo -e "\nüì¶ All Pods:"
            echo "============"
            sudo /usr/local/bin/k0s kubectl get pods -A -o wide

            echo -e "\nüåê Services:"
            echo "============"
            sudo /usr/local/bin/k0s kubectl get svc -A

            echo -e "\nüö™ Ingress:"
            echo "==========="
            sudo /usr/local/bin/k0s kubectl get ingress -A

            echo -e "\nüåç Web Application Pods:"
            echo "========================"
            sudo /usr/local/bin/k0s kubectl get pods -n webserver -o wide

            echo -e "\nüìù Cloudflare Controller Status:"
            echo "================================"
            sudo /usr/local/bin/k0s kubectl get deployment -n cloudflare-tunnel

            # Get controller logs
            POD=$(sudo /usr/local/bin/k0s kubectl get pods -n cloudflare-tunnel -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
            if [ -n "$POD" ]; then
              echo -e "\nController logs (last 20 lines):"
              sudo /usr/local/bin/k0s kubectl logs -n cloudflare-tunnel $POD --tail=20 || echo "Logs not yet available"
            fi
          EOF

      - name: Test internal connectivity
        run: |
          echo "üß™ Testing web service internally..."
          ssh -o StrictHostKeyChecking=no opc@k8s-controller << 'EOF'
            # Check service endpoints first
            echo "Service endpoints:"
            sudo /usr/local/bin/k0s kubectl get endpoints -n webserver
            echo ""
            
            # Test connectivity using a job instead of interactive pod
            echo "Testing web service connectivity..."
            
            # Create test job manifest
            cat > /tmp/test-connectivity-job.yaml << 'JOBEND'
            apiVersion: batch/v1
            kind: Job
            metadata:
              name: test-connectivity
              namespace: webserver
            spec:
              ttlSecondsAfterFinished: 300
              template:
                spec:
                  restartPolicy: Never
                  containers:
                  - name: curl-test
                    image: docker.io/curlimages/curl:latest
                    command: ["curl"]
                    args: ["-s", "-o", "/dev/null", "-w", "HTTP Status: %{http_code}\n", "http://webserver-service"]
          JOBEND
            
            # Apply the job
            sudo /usr/local/bin/k0s kubectl apply -f /tmp/test-connectivity-job.yaml
            
            # Wait for job completion with shorter timeout
            echo "Waiting for connectivity test to complete..."
            if sudo /usr/local/bin/k0s kubectl wait --for=condition=complete --timeout=30s job/test-connectivity -n webserver; then
              # Get the results
              echo "Test results:"
              sudo /usr/local/bin/k0s kubectl logs job/test-connectivity -n webserver
            else
              echo "Job timed out, checking status and logs anyway..."
              sudo /usr/local/bin/k0s kubectl describe job/test-connectivity -n webserver
              echo "Pod logs (if available):"
              sudo /usr/local/bin/k0s kubectl logs job/test-connectivity -n webserver || echo "No logs available yet"
              
              # Alternative quick test
              echo "Running alternative connectivity test..."
              sudo /usr/local/bin/k0s kubectl run quick-test --image=busybox --rm --restart=Never -- wget -qO- --timeout=5 http://webserver-service.webserver.svc.cluster.local | head -5 || echo "Quick test failed"
            fi
            
            # Clean up
            sudo /usr/local/bin/k0s kubectl delete job test-connectivity -n webserver
            rm -f /tmp/test-connectivity-job.yaml
          EOF

      - name: Mark deployment complete
        id: deployment_status
        run: |
          echo "status=success" >> $GITHUB_OUTPUT
          echo "‚úÖ Application deployment completed successfully"

      - name: Display deployment summary
        run: |
          echo "========================================="
          echo "üéâ K0s Kubernetes Cluster Deployed!"
          echo "========================================="
          echo ""
          echo "üñ•Ô∏è  Cluster Access:"
          echo "  SSH: ssh opc@k8s-controller"
          echo "  Kubectl: sudo /usr/local/bin/k0s kubectl get pods -A"
          echo ""
          echo "üåê Application:"
          echo "  Domain: mclaurinquist.com"
          echo "  Replicas: 2 (distributed across workers)"
          echo ""
          echo "üìä Resource Usage:"
          echo "  Controller: 1 OCPU, 6GB RAM (k0s control plane)"
          echo "  Worker-1: 1 OCPU, 6GB RAM + 50GB storage"
          echo "  Worker-2: 1 OCPU, 6GB RAM"
          echo "  Total: 3/4 OCPUs, 18/24GB RAM used"
          echo ""
          echo "üîç Useful Commands:"
          echo "  Watch pods: watch 'sudo /usr/local/bin/k0s kubectl get pods -A'"
          echo "  App logs: sudo /usr/local/bin/k0s kubectl logs -f -n webserver deployment/webserver"
          echo "  Node resources: sudo /usr/local/bin/k0s kubectl top nodes"
          echo ""
          echo "üìà Next Steps:"
          echo "  1. Verify website at https://mclaurinquist.com"
          echo "  2. Test rolling updates with update-app-only workflow"
          echo "  3. Add monitoring stack when ready"
          echo "========================================="
